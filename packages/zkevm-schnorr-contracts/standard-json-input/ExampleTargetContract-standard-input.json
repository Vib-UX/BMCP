{"language":"Solidity","sources":{"src/ExampleTargetContract.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title ExampleTargetContract\n * @dev Example contract that can be called via BMCP messages from Bitcoin\n * @notice This demonstrates various function calls that can be triggered from Bitcoin\n */\ncontract ExampleTargetContract {\n    \n    // Events\n    event MessageReceived(\n        address indexed sender,\n        string message,\n        uint256 timestamp\n    );\n    \n    event TokensTransferred(\n        address indexed from,\n        address indexed to,\n        uint256 amount\n    );\n    \n    event DataStored(\n        bytes32 indexed key,\n        bytes data,\n        address indexed storer\n    );\n    \n    event BatchExecuted(\n        address[] targets,\n        bytes[] calls,\n        bool[] successes\n    );\n    \n    // State\n    mapping(address => string) public userMessages;\n    mapping(address => uint256) public balances;\n    mapping(bytes32 => bytes) public dataStore;\n    uint256 public messageCount;\n    \n    /**\n     * @dev Store a message from Bitcoin user\n     * @param message The message to store\n     */\n    function storeMessage(string calldata message) external {\n        userMessages[msg.sender] = message;\n        messageCount++;\n        \n        emit MessageReceived(msg.sender, message, block.timestamp);\n    }\n    \n    /**\n     * @dev Transfer tokens between addresses\n     * @param to Recipient address\n     * @param amount Amount to transfer\n     */\n    function transfer(address to, uint256 amount) external {\n        require(to != address(0), \"Invalid recipient\");\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n        \n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n        \n        emit TokensTransferred(msg.sender, to, amount);\n    }\n    \n    /**\n     * @dev Store arbitrary data\n     * @param key Storage key\n     * @param data Data to store\n     */\n    function storeData(bytes32 key, bytes calldata data) external {\n        dataStore[key] = data;\n        \n        emit DataStored(key, data, msg.sender);\n    }\n    \n    /**\n     * @dev Mint tokens to address (for testing)\n     * @param to Recipient address\n     * @param amount Amount to mint\n     */\n    function mint(address to, uint256 amount) external {\n        require(to != address(0), \"Invalid recipient\");\n        \n        balances[to] += amount;\n        \n        emit TokensTransferred(address(0), to, amount);\n    }\n    \n    /**\n     * @dev Execute batch of calls\n     * @param targets Array of target contracts\n     * @param calls Array of calldata\n     */\n    function batchExecute(\n        address[] calldata targets,\n        bytes[] calldata calls\n    ) external {\n        require(targets.length == calls.length, \"Length mismatch\");\n        \n        bool[] memory successes = new bool[](targets.length);\n        \n        for (uint256 i = 0; i < targets.length; i++) {\n            (bool success, ) = targets[i].call(calls[i]);\n            successes[i] = success;\n        }\n        \n        emit BatchExecuted(targets, calls, successes);\n    }\n    \n    /**\n     * @dev Swap tokens (mock implementation)\n     * @param tokenIn Input token address\n     * @param tokenOut Output token address\n     * @param amountIn Amount of input tokens\n     * @param minAmountOut Minimum output tokens\n     */\n    function swap(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) external returns (uint256 amountOut) {\n        require(tokenIn != address(0) && tokenOut != address(0), \"Invalid tokens\");\n        require(amountIn > 0, \"Invalid amount\");\n        \n        // Mock swap logic (1:1 for demonstration)\n        amountOut = amountIn;\n        require(amountOut >= minAmountOut, \"Slippage too high\");\n        \n        emit TokensTransferred(msg.sender, address(this), amountIn);\n        emit TokensTransferred(address(this), msg.sender, amountOut);\n        \n        return amountOut;\n    }\n    \n    /**\n     * @dev Get user's message\n     */\n    function getMessage(address user) external view returns (string memory) {\n        return userMessages[user];\n    }\n    \n    /**\n     * @dev Get user's balance\n     */\n    function getBalance(address user) external view returns (uint256) {\n        return balances[user];\n    }\n    \n    /**\n     * @dev Get stored data\n     */\n    function getData(bytes32 key) external view returns (bytes memory) {\n        return dataStore[key];\n    }\n}\n\n"}},"settings":{"remappings":["forge-std/=lib/forge-std/src/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","viaIR":false,"libraries":{}}}
