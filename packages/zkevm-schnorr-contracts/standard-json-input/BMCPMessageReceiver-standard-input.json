{"language":"Solidity","sources":{"src/BMCPMessageReceiver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title BMCPMessageReceiver\n * @dev Receives and verifies Bitcoin OP_RETURN messages with Schnorr signature verification\n * @notice This contract integrates with BMCP protocol to:\n *   1. Receive messages from Bitcoin via relayer\n *   2. Verify Schnorr signatures from Bitcoin transaction inputs\n *   3. Check authorization constraints (allowed contracts, functions, limits)\n *   4. Execute authorized function calls\n */\ncontract BMCPMessageReceiver {\n    \n    // Citrea Schnorr precompile address\n    address constant SCHNORR_VERIFY_PRECOMPILE = 0x0000000000000000000000000000000000000200;\n    \n    // Events\n    event MessageReceived(\n        bytes32 indexed txid,\n        bytes32 indexed bitcoinPubKeyX,\n        address targetContract,\n        bytes4 functionSelector,\n        uint256 nonce\n    );\n    \n    event SignatureVerified(\n        bytes32 indexed txid,\n        bytes32 bitcoinPubKeyX,\n        bytes32 messageHash,\n        bool isValid\n    );\n    \n    event FunctionExecuted(\n        bytes32 indexed txid,\n        address indexed targetContract,\n        bytes4 indexed functionSelector,\n        bool success,\n        bytes returnData\n    );\n    \n    event AuthorizationViolation(\n        bytes32 indexed txid,\n        string reason\n    );\n    \n    // Structs\n    struct Authorization {\n        address allowedContract;     // Which contract can be called\n        bytes4 allowedFunction;      // Which function can be called\n        uint256 maxValue;            // Maximum value in wei\n        uint256 validUntil;          // Expiry timestamp\n    }\n    \n    struct BMCPMessage {\n        bytes2 protocol;             // 0x4243 (\"BC\")\n        uint64 chainSelector;        // Destination chain\n        address targetContract;      // Contract to call\n        bytes data;                  // Function calldata\n        uint256 nonce;               // Replay protection\n        uint256 deadline;            // Message deadline\n        Authorization authorization; // Authorization constraints\n    }\n    \n    struct SchnorrProof {\n        bytes32 pubKeyX;             // Bitcoin public key X coordinate\n        bytes signature;             // 64-byte Schnorr signature\n    }\n    \n    // State\n    address public owner;\n    address public relayer;\n    mapping(bytes32 => bool) public processedMessages;  // txid => processed\n    mapping(bytes32 => uint256) public bitcoinNonces;   // pubKeyX => nonce\n    \n    // Modifiers\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n    \n    modifier onlyRelayer() {\n        require(msg.sender == relayer, \"Only relayer\");\n        _;\n    }\n    \n    constructor(address _relayer) {\n        owner = msg.sender;\n        relayer = _relayer;\n    }\n    \n    /**\n     * @dev Main entry point for BMCP messages from Bitcoin\n     * @param txid Bitcoin transaction ID\n     * @param message The decoded BMCP message from OP_RETURN\n     * @param proof Schnorr signature proof from Bitcoin transaction input\n     */\n    function receiveMessage(\n        bytes32 txid,\n        BMCPMessage calldata message,\n        SchnorrProof calldata proof\n    ) external onlyRelayer returns (bool) {\n        \n        // Check if message already processed\n        require(!processedMessages[txid], \"Message already processed\");\n        \n        // Check message deadline\n        require(block.timestamp <= message.deadline, \"Message expired\");\n        \n        // Check authorization deadline\n        if (message.authorization.validUntil > 0) {\n            require(\n                block.timestamp <= message.authorization.validUntil,\n                \"Authorization expired\"\n            );\n        }\n        \n        // Emit received event\n        emit MessageReceived(\n            txid,\n            proof.pubKeyX,\n            message.targetContract,\n            bytes4(message.data),\n            message.nonce\n        );\n        \n        // Step 1: Verify Schnorr signature\n        bool isValidSignature = _verifySchnorrSignature(\n            txid,\n            message,\n            proof\n        );\n        \n        if (!isValidSignature) {\n            emit AuthorizationViolation(txid, \"Invalid Schnorr signature\");\n            return false;\n        }\n        \n        // Step 2: Verify authorization constraints\n        bool isAuthorized = _verifyAuthorization(txid, message);\n        \n        if (!isAuthorized) {\n            return false;\n        }\n        \n        // Step 3: Check and update nonce\n        uint256 expectedNonce = bitcoinNonces[proof.pubKeyX];\n        require(message.nonce == expectedNonce, \"Invalid nonce\");\n        bitcoinNonces[proof.pubKeyX] = expectedNonce + 1;\n        \n        // Step 4: Mark as processed\n        processedMessages[txid] = true;\n        \n        // Step 5: Execute the function call\n        bool success = _executeCall(txid, message);\n        \n        return success;\n    }\n    \n    /**\n     * @dev Verify Schnorr signature from Bitcoin transaction\n     * @param txid Bitcoin transaction ID\n     * @param message The BMCP message\n     * @param proof Schnorr proof containing pubkey and signature\n     */\n    function _verifySchnorrSignature(\n        bytes32 txid,\n        BMCPMessage calldata message,\n        SchnorrProof calldata proof\n    ) internal returns (bool) {\n        \n        // Create message hash from the BMCP message data\n        bytes32 messageHash = keccak256(\n            abi.encode(\n                message.protocol,\n                message.chainSelector,\n                message.targetContract,\n                message.data,\n                message.nonce,\n                message.deadline\n            )\n        );\n        \n        // Verify signature length\n        require(proof.signature.length == 64, \"Invalid signature length\");\n        \n        // Call Citrea Schnorr precompile\n        bytes memory input = abi.encodePacked(\n            proof.pubKeyX,\n            messageHash,\n            proof.signature\n        );\n        \n        (bool ok, bytes memory output) = SCHNORR_VERIFY_PRECOMPILE.staticcall(input);\n        \n        // Check result: 32-byte return, last byte == 0x01 means success\n        bool isValid = ok && output.length == 32 && output[31] == 0x01;\n        \n        emit SignatureVerified(txid, proof.pubKeyX, messageHash, isValid);\n        \n        return isValid;\n    }\n    \n    /**\n     * @dev Verify authorization constraints\n     * @param txid Bitcoin transaction ID\n     * @param message The BMCP message\n     */\n    function _verifyAuthorization(\n        bytes32 txid,\n        BMCPMessage calldata message\n    ) internal returns (bool) {\n        \n        Authorization calldata auth = message.authorization;\n        \n        // Check allowed contract\n        if (auth.allowedContract != address(0)) {\n            if (message.targetContract != auth.allowedContract) {\n                emit AuthorizationViolation(txid, \"Unauthorized contract\");\n                return false;\n            }\n        }\n        \n        // Check allowed function\n        if (auth.allowedFunction != bytes4(0)) {\n            bytes4 functionSelector = bytes4(message.data);\n            if (functionSelector != auth.allowedFunction) {\n                emit AuthorizationViolation(txid, \"Unauthorized function\");\n                return false;\n            }\n        }\n        \n        // Check max value (if msg.value involved)\n        if (auth.maxValue > 0 && msg.value > auth.maxValue) {\n            emit AuthorizationViolation(txid, \"Value exceeds maximum\");\n            return false;\n        }\n        \n        return true;\n    }\n    \n    /**\n     * @dev Execute the authorized function call\n     * @param txid Bitcoin transaction ID\n     * @param message The BMCP message\n     */\n    function _executeCall(\n        bytes32 txid,\n        BMCPMessage calldata message\n    ) internal returns (bool) {\n        \n        // Execute the call\n        (bool success, bytes memory returnData) = message.targetContract.call{\n            value: 0  // No ETH transfer for now\n        }(message.data);\n        \n        emit FunctionExecuted(\n            txid,\n            message.targetContract,\n            bytes4(message.data),\n            success,\n            returnData\n        );\n        \n        return success;\n    }\n    \n    /**\n     * @dev Update relayer address (only owner)\n     */\n    function setRelayer(address _relayer) external onlyOwner {\n        require(_relayer != address(0), \"Invalid relayer address\");\n        relayer = _relayer;\n    }\n    \n    /**\n     * @dev Check if message has been processed\n     */\n    function isMessageProcessed(bytes32 txid) external view returns (bool) {\n        return processedMessages[txid];\n    }\n    \n    /**\n     * @dev Get current nonce for a Bitcoin public key\n     */\n    function getNonce(bytes32 pubKeyX) external view returns (uint256) {\n        return bitcoinNonces[pubKeyX];\n    }\n    \n    /**\n     * @dev Verify a signature without processing (for testing)\n     */\n    function verifySignatureOnly(\n        bytes32 pubKeyX,\n        bytes32 messageHash,\n        bytes calldata signature\n    ) external view returns (bool) {\n        require(signature.length == 64, \"Invalid signature length\");\n        \n        bytes memory input = abi.encodePacked(\n            pubKeyX,\n            messageHash,\n            signature\n        );\n        \n        (bool ok, bytes memory output) = SCHNORR_VERIFY_PRECOMPILE.staticcall(input);\n        \n        return ok && output.length == 32 && output[31] == 0x01;\n    }\n}\n\n"}},"settings":{"remappings":["forge-std/=lib/forge-std/src/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","viaIR":false,"libraries":{}}}
