{"language":"Solidity","sources":{"src/SchnorrVerifyCaller.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @title Schnorr Precompile Example\n/// @notice Calls the Schnorr precompile to verify BIP340 secp256k1 signatures\ncontract SchnorrVerifyCaller {\n    address constant SCHNORR_VERIFY_PRECOMPILE = 0x0000000000000000000000000000000000000200;\n\n    // Events for testing\n    event SchnorrVerificationResult(\n        bytes32 indexed messageHash,\n        bytes32 indexed pubKeyX,\n        bytes signature,\n        bool isValid,\n        bytes precompileOutput\n    );\n\n    /**\n     * @notice Verifies a BIP340 Schnorr signature.\n     * @dev All inputs must be big-endian byte sequences.\n     * @param pubKeyX 32-byte public key X coordinate (big-endian, Y is implicitly even per BIP340)\n     * @param messageHash 32-byte hash of the signed message\n     * @param signature 64-byte Schnorr signature (r || s), both 32-byte values concatenated\n     * @return isValid True if signature is valid, false otherwise.\n     */\n    function schnorrVerify(\n        bytes32 pubKeyX,\n        bytes32 messageHash,\n        bytes calldata signature // must be 64 bytes\n    ) external view returns (bool isValid) {\n        require(signature.length == 64, \"Invalid signature length\");\n        // Concatenate inputs in correct order: pubKeyX | messageHash | signature\n        bytes memory input = abi.encodePacked(\n            pubKeyX,\n            messageHash,\n            signature\n        );\n        (bool ok, bytes memory output) = SCHNORR_VERIFY_PRECOMPILE.staticcall(input);\n        // 32-byte return, last byte == 0x01 means success\n        return ok && output.length == 32 && output[31] == 0x01;\n    }\n\n    /**\n     * @notice Verifies a BIP340 Schnorr signature with detailed logging.\n     * @dev Same as schnorrVerify but emits events for debugging\n     */\n    function schnorrVerifyWithLogging(\n        bytes32 pubKeyX,\n        bytes32 messageHash,\n        bytes calldata signature\n    ) external returns (bool isValid) {\n        require(signature.length == 64, \"Invalid signature length\");\n        \n        // Concatenate inputs in correct order: pubKeyX | messageHash | signature\n        bytes memory input = abi.encodePacked(\n            pubKeyX,\n            messageHash,\n            signature\n        );\n        \n        (bool ok, bytes memory output) = SCHNORR_VERIFY_PRECOMPILE.staticcall(input);\n        \n        // Check if signature is valid\n        bool valid = ok && output.length == 32 && output[31] == 0x01;\n        \n        // Emit event with all details for debugging\n        emit SchnorrVerificationResult(\n            messageHash,\n            pubKeyX,\n            signature,\n            valid,\n            output\n        );\n        \n        return valid;\n    }\n\n    /**\n     * @notice Test the precompile with known test vectors\n     * @dev This function tests with hardcoded values to verify precompile functionality\n     */\n    function testPrecompile() external returns (bool) {\n        // Test with all zeros (should fail)\n        bytes32 testPubKeyX = 0x0000000000000000000000000000000000000000000000000000000000000000;\n        bytes32 testMessageHash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n        bytes memory testSignature = new bytes(64);\n        // testSignature is already all zeros\n        \n        return this.schnorrVerifyWithLogging(testPubKeyX, testMessageHash, testSignature);\n    }\n\n    /**\n     * @notice Get precompile raw response for debugging\n     */\n    function getPrecompileResponse(\n        bytes32 pubKeyX,\n        bytes32 messageHash,\n        bytes calldata signature\n    ) external view returns (bool ok, bytes memory output) {\n        require(signature.length == 64, \"Invalid signature length\");\n        \n        bytes memory input = abi.encodePacked(\n            pubKeyX,\n            messageHash,\n            signature\n        );\n        \n        return SCHNORR_VERIFY_PRECOMPILE.staticcall(input);\n    }\n}\n"}},"settings":{"remappings":["forge-std/=lib/forge-std/src/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","viaIR":false,"libraries":{}}}
